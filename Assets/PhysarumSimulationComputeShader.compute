// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateAgent

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
const float PI = 3.141;

RWTexture2D<float4> UpdateAgentTrailMap;

struct Agent
{
    float2 position;
    float speed;
    float angle;
};

RWStructuredBuffer<Agent> Agents;

int canvasWidth;
int canvasHeight;
uint numAgents;

uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}

[numthreads(16,1,1)]
void UpdateAgent (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numAgents) return;

    Agent agent = Agents[id.x];
    float2 position = agent.position;
    float speed = agent.speed;
    float angle = agent.angle;

    float sampleAngle, sampleLeft, sampleStraight, sampleRight;
    float2 sampleOffset;

    // Sampling Left
    sampleAngle = angle + 0.5;
    sampleOffset = 4 * float2(cos(sampleAngle), sin(sampleAngle));
    sampleLeft = UpdateAgentTrailMap[int2(position + sampleOffset)].r;

    // Sample Straight
    sampleAngle = angle;
    sampleOffset = 4 * float2(cos(sampleAngle), sin(sampleAngle));
    sampleStraight = UpdateAgentTrailMap[int2(position + sampleOffset)].r;

    // Sample Right
    sampleAngle = angle - 0.5;
    sampleOffset = 4 * float2(cos(sampleAngle), sin(sampleAngle));
    sampleRight = UpdateAgentTrailMap[int2(position + sampleOffset)].r;

    if (sampleStraight < sampleLeft && sampleStraight < sampleRight)
	{
		uint random = hash(position.y * canvasWidth + position.x);
		float randomSteerStrength = scaleToRange01(random);

		if (randomSteerStrength >= 0.5) Agents[id.x].angle -= 0.78;
		else Agents[id.x].angle += 0.78;
	}
	else if (sampleLeft < sampleRight)
	{
		Agents[id.x].angle -= 0.78;
	}
	else if (sampleLeft > sampleRight)
	{
		Agents[id.x].angle += 0.78;
	}

    float2 velocity = speed * float2(cos(angle), sin(angle));
    float2 newPosition = position + velocity;

    bool updatePosition = true;

    if (newPosition.x <= 0 || newPosition.x >= canvasWidth)
    {
        Agents[id.x].angle = 3.14 - angle;
        updatePosition = false;
    }

    if (newPosition.y <= 0 || newPosition.y >= canvasHeight)
    {
        Agents[id.x].angle *= -1;
        updatePosition = false;
    }

    if (updatePosition) Agents[id.x].position = newPosition; 

    UpdateAgentTrailMap[int2(position)] = float4(1, 1, 1, 1);
}

#pragma kernel DiffuseAndDissipate

RWTexture2D<float4> DiffuseAndDissipateTrailMap;

[numthreads(8,8,1)]
void DiffuseAndDissipate (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)canvasWidth || id.y < 0 || id.y >= (uint)canvasHeight) {
		return;
	}
    
    float4 originalValue = DiffuseAndDissipateTrailMap[id.xy];

	// 3x3 blur simulates diffusion
    float4 sum = 0;
	for (int offsetX = -1; offsetX <= 1; offsetX ++) {
		for (int offsetY = -1; offsetY <= 1; offsetY ++) {
			int sampleX = min(canvasWidth-1, max(0, id.x + offsetX));
			int sampleY = min(canvasHeight-1, max(0, id.y + offsetY));
			sum += DiffuseAndDissipateTrailMap[int2(sampleX, sampleY)];
		}
	}
    float4 diffusedValue = sum / 9;

    // Subtracting value simulates dissipation
    DiffuseAndDissipateTrailMap[id.xy] = max(0, diffusedValue - 0.001);
}